{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/std_forward/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"std::forward\",\n  \"tags\": [\"c++\", \"stl\"],\n  \"emoji\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this note, I'm trying to demonstrate the usage of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::forward\"), \" where without it, there is no easy workaround. To understand the usage, one has to know some basic concept of lvalue and rvalue C++. (Basic cases should be sufficient).\"), mdx(\"p\", null, \"From a high level, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::forward\"), \" helps us fowarding a type information of a variable \\\"perfectly\\\". Let's start with some example to explain the task.\"), mdx(\"h1\", {\n    \"id\": \"perfect-forwarding\"\n  }, \"Perfect Forwarding\"), mdx(\"p\", null, \"Let's start with a super simple class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat\"), \" with an overloaded method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meow\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"class Cat {\\n public:\\n  void meow() { std::cout << \\\"meow()\\\" << std::endl; }\\n  void meow() const { std::cout << \\\"meow() const\\\" << std::endl; }\\n};\\n\")), mdx(\"p\", null, \"We overloaded \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meow\"), \" function to distinguish the cases whether the object is a constant. A simple test run:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"Cat cat1;\\nconst Cat cat2;\\ncat1.meow(); // meow()\\ncat2.meow(); // meow() const\\n\")), mdx(\"p\", null, \"For some reason, we need a (trivial) wrapper, so we have to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"forward\"), \" the function call.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"void callMeow(const Cat &cat) { cat.meow(); }\\n\")), mdx(\"p\", null, \"Note that, we are trying to foward, so we pass by reference to avoid copying. In that case, we \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"must\"), \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" the argument. Otherwise, the compiler won't let us pass in a constant object as it will loss the qualifier.\"), mdx(\"p\", null, \"When we invoke the wrapper:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"callMeow(cat1); // meow() const\\ncallMeow(cat2); // meow() const\\n\")), mdx(\"p\", null, \"which is not surprising. But it is not we want if we'd like to have \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"perfect forwarding\"), \". An obvious solution is to overload the functions and implement the wrapper twice with different arguments. As a programmer, we often want to avoid code copying. Therefore, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"template\"), \" comes for the resecue!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"template <typename T_Cat>\\nvoid callMeow(T_Cat &cat) {\\n  cat.purr();\\n}\\n\")), mdx(\"p\", null, \"The above template function can forward the type information -- whether it is a constant perfectly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"callMeow(cat1); // meow()\\ncallMeow(cat2); // meow() const\\n\")), mdx(\"p\", null, \"Neat! This behavior is what we call \\\"perfect forwarding\\\". With template, we can forward the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" information. However, without extra trick, some type information that we cannot forward easily.\"), mdx(\"h3\", {\n    \"id\": \"the-problem\"\n  }, \"The problem\"), mdx(\"p\", null, \"Now let's overload another function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"purr\"), \" for lvalue and rvalue objects. (It can combine with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" qualifier. See the next section with full code examples)\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"class Cat {\\n public:\\n  void purr() & { std::cout << \\\"purr() lvalue\\\" << std::endl; }\\n  void purr() && { std::cout << \\\"purr() rvalue\\\" << std::endl; }\\n};\\n\")), mdx(\"p\", null, \"Can we still do the perect forwarding with template?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"template <typename T_Cat>\\nvoid callPurr(T_Cat &cat) {\\n  cat.purr();\\n}\\n\\nCat cat;\\ncallPurr(cat); // purr() lvalue\\ncallPurr(Cat{}); // COMPILE ERROR\\n\")), mdx(\"p\", null, \"It turns out that when we pass in an rvalue, it doesn't even compile! Because it's passing by reference, in which case, the arguemnt cannot be an rvalue.\"), mdx(\"h1\", {\n    \"id\": \"solution\"\n  }, \"Solution\"), mdx(\"p\", null, \" To handle lvalue and rvalue at the same time, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"universal reference\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \" was introduced in C++11.\"), mdx(\"p\", null, \"With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T_Cat\"), \" will become \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat&\"), \" when the argument is a lvalue as usual; when it's an rvalue, it becomes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat\"), \", which works fine:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"template <typename T_Cat>\\nvoid callPurr(T_Cat &&cat) {\\n  cat.purr();\\n}\\n\\nCat cat;\\ncallPurr(cat); // purr() lvalue\\ncallPurr(Cat{}); // purr() lvalue\\n\")), mdx(\"p\", null, \"It compiles now. However, it is not what we expected! After second thought with the above interpretation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"&&\"), \", it's actually understandable. When we passed in a rvalue, it consider it as the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cat\"), \", so it's a new (lvalue) copy.\"), mdx(\"p\", null, \"Finally, along all the way, we reach to the topic of this note, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::forward\"), \". It helps us forward the \\\"rvalue information\\\". The usage is as follows.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"template <typename T_Cat>\\nvoid callPurr(T_Cat &&cat) {\\n  std::forward<T_Cat>(cat).purr();\\n}\\n\\nCat cat;\\ncallPurr(cat); // purr() lvalue\\ncallPurr(Cat{}); // purr() rvalue\\n\")), mdx(\"p\", null, \"Perfect! And that's it. Hopefully, it will be helpful for understanding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::forward\"), \" or even dealing with rvalue for the sake of efficiency.\"), mdx(\"h1\", {\n    \"id\": \"full-code-examples\"\n  }, \"Full code examples\"), mdx(\"h3\", {\n    \"id\": \"source-code\"\n  }, \"source code\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-c++\"\n  }), \"#include <iostream>\\n#include <utility>\\n\\nclass Cat {\\n public:\\n  void meow() { std::cout << \\\"meow()\\\" << std::endl; }\\n  void meow() const { std::cout << \\\"meow() const\\\" << std::endl; }\\n\\n  void purr() & { std::cout << \\\"purr() &\\\" << std::endl; }\\n  void purr() && { std::cout << \\\"purr() &&\\\" << std::endl; }\\n  void purr() const & { std::cout << \\\"purr() const &\\\" << std::endl; }\\n  void purr() const && { std::cout << \\\"purr() const &&\\\" << std::endl; }\\n};\\n\\nvoid callMeow(const Cat &cat) { cat.meow(); }\\n\\ntemplate <typename T_Cat>\\nvoid callMeowTemplate(T_Cat &cat) {\\n  cat.meow();\\n}\\n\\ntemplate <typename T_Cat>\\nvoid callPurrTemplate(T_Cat &cat) {\\n  cat.purr();\\n}\\n\\ntemplate <typename T_Cat>\\nvoid callPurrTemplateUniversalRef(T_Cat &&cat) {\\n  cat.purr();\\n}\\n\\ntemplate <typename T_Cat>\\nvoid callPurrTemplateUniversalRefForward(T_Cat &&cat) {\\n  std::forward<T_Cat>(cat).purr();\\n}\\n\\nint main() {\\n  Cat cat1;\\n  const Cat cat2;\\n  std::cout << \\\"### Call Meow directly\\\" << std::endl;\\n  cat1.meow();\\n  cat2.meow();\\n  std::cout << std::endl;\\n\\n  std::cout << \\\"### Call Meow\\\" << std::endl;\\n  callMeow(cat1);\\n  callMeow(cat2);\\n  std::cout << std::endl;\\n\\n  std::cout << \\\"### Call Meow template\\\" << std::endl;\\n  callMeowTemplate(cat1);\\n  callMeowTemplate(cat2);\\n  std::cout << std::endl;\\n\\n  std::cout << \\\"### Call Purr directly\\\" << std::endl;\\n  cat1.purr();\\n  cat2.purr();\\n  Cat{}.purr();\\n  {\\n    const Cat tmpCat;\\n    std::move(tmpCat).purr();\\n  }\\n  std::cout << std::endl;\\n\\n  std::cout << \\\"### Call Purr Template (Ref)\\\" << std::endl;\\n  callPurrTemplate(cat1);\\n  callPurrTemplate(cat2);\\n  // callPurrTemplate(Cat{}); // It expects an lvalue\\n  std::cout << std::endl;\\n\\n  std::cout << \\\"### Call Purr Template (Universal reference)\\\" << std::endl;\\n  callPurrTemplateUniversalRef(cat1);\\n  callPurrTemplateUniversalRef(cat2);\\n  callPurrTemplateUniversalRef(Cat{});\\n  {\\n    const Cat tmpCat;\\n    callPurrTemplateUniversalRef(std::move(tmpCat));\\n  }\\n  std::cout << std::endl;\\n\\n  std::cout << \\\"### Call Purr Template (Universal reference and Forward)\\\"\\n            << std::endl;\\n  callPurrTemplateUniversalRefForward(cat1);\\n  callPurrTemplateUniversalRefForward(cat2);\\n  callPurrTemplateUniversalRefForward(Cat{});\\n  {\\n    const Cat tmpCat;\\n    callPurrTemplateUniversalRefForward(std::move(tmpCat));\\n  }\\n  std::cout << std::endl;\\n  return 0;\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"result\"\n  }, \"Result\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"### Call Meow directly\\nmeow()\\nmeow() const\\n\\n### Call Meow\\nmeow() const\\nmeow() const\\n\\n### Call Meow template\\nmeow()\\nmeow() const\\n\\n### Call Purr directly\\npurr() &\\npurr() const &\\npurr() &&\\npurr() const &&\\n\\n### Call Purr Template (Ref)\\npurr() &\\npurr() const &\\n\\n### Call Purr Template (Universal reference)\\npurr() &\\npurr() const &\\npurr() &\\npurr() const &\\n\\n### Call Purr Template (Universal reference and Forward)\\npurr() &\\npurr() const &\\npurr() &&\\npurr() const &&\\n\\n\\n\")), mdx(\"h1\", {\n    \"id\": \"reference\"\n  }, \"Reference\"), mdx(\"p\", null, \"Mainly from this \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://kksnote.logdown.com/posts/1653018-c-forward-11-perfect-forwarding-are-what\"\n  }), \"blog post\"), \" and with various helps from stackover flow and the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.cppreference.com/w/\"\n  }), \"c++ reference\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"std::forward","tags":["c++","stl"],"emoji":null,"link":null},"fields":{"slug":"/std_forward/"},"tableOfContents":{"items":[{"url":"#perfect-forwarding","title":"Perfect Forwarding","items":[{"items":[{"url":"#the-problem","title":"The problem"}]}]},{"url":"#solution","title":"Solution"},{"url":"#full-code-examples","title":"Full code examples","items":[{"items":[{"url":"#source-code","title":"source code"},{"url":"#result","title":"Result"}]}]},{"url":"#reference","title":"Reference"}]},"parent":{"__typename":"File","relativePath":"std_forward.md"}}},"pageContext":{"id":"b95e456f-c896-56de-96a1-9d218d704174","previous":{"id":"38223809-f428-5ab5-a208-26663e9c309a","frontmatter":{"title":"How to generate and maintain this site","tags":["gatsby","code-notes"]},"fields":{"slug":"/code_notes/"}},"next":{"id":"06ae374b-a330-5492-8f63-952d481cda7e","frontmatter":{"title":"Remove elements in a vector","tags":["c++"]},"fields":{"slug":"/remove_if/"}},"hasUntagged":false,"basePath":"/"}},"staticQueryHashes":["1437003973","2744905544","3664657028","467212769","467212769"]}